#!/usr/bin/env groovy

/*
  Copyright (C) 2020 Collabora Limited
  Author: Guillaume Tucker <guillaume.tucker@collabora.com>

  This module is free software; you can redistribute it and/or modify it under
  the terms of the GNU Lesser General Public License as published by the Free
  Software Foundation; either version 2.1 of the License, or (at your option)
  any later version.

  This library is distributed in the hope that it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
  details.

  You should have received a copy of the GNU Lesser General Public License
  along with this library; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*/

@Library('kernelci') _
import org.kernelci.util.Job

def eggCache() {
    def egg_cache = env.WORKSPACE + "/python-egg-cache"
    sh(script: "mkdir -p ${egg_cache}")
    return egg_cache
}

def gitDescribe(kdir) {
    def describe

    dir(kdir) {
        describe = sh(script: "git describe", returnStdout: true).trim()
    }

    return describe
}

def createTag(kdir) {
    def tag = gitDescribe(kdir)

    dir(kdir) {
        tag += "-${env.JOB_NAME}-staging-${currentBuild.number}"
        sh(script: "git tag -a ${tag} -m ${tag} HEAD")
    }

    return tag
}

def removeTag(kdir, tag) {
    dir(kdir) {
        sh(script: "git tag -d ${tag}")
    }
}

def checkoutRevision(git_dir, git_rev) {
    dir(git_dir) {
        sh(script: """
git clean -fd && \
git checkout --detach ${git_rev}
""")
    }
}

def setRemote(kdir, name, url) {
    dir(kdir) {
        sh(script: """
if git remote | grep -e '^${name}\$'; then
    git remote set-url ${name} ${url}
    git remote update ${name}
    git remote prune ${name}
else
    git remote add ${name} ${url}
    git remote update ${name}
fi
""")
    }
}

def cloneKciCore(kci_core) {
    def j = new Job()
    j.cloneKciCore(kci_core, params.KCI_CORE_URL, params.KCI_CORE_BRANCH)
}

def cloneLinux(kdir) {
    print("""\
Initialising kernel tree
  url:    ${params.KERNEL_URL}
  branch: ${params.KERNEL_BRANCH}
  path:   ${kdir}""")

    def is_git = !sh(returnStatus: true, script: "test -d ${kdir}/.git")
    def is_valid = (is_git &&
                    !sh(returnStatus: true, script: "cd ${kdir}; git status"))

    if (is_valid) {
        setRemote(kdir, params.KERNEL_TREE, params.KERNEL_URL)
    } else {
        if (is_git) {
            print("Broken Git clone, recreating ${kdir}")
            sh(script: "rm -rf ${kdir}")
        }

        sh(script: """
git clone ${params.KERNEL_URL} ${kdir} \
  -b ${params.KERNEL_BRANCH} \
  -o ${params.KERNEL_TREE}
""")
    }

    dir(kdir) {
        sh(script: """
git config user.name 'kernelci.org bot'
git config user.email bot@kernelci.org
git reset --hard
echo 'build-*' > .git/info/exclude
git clean -fd
git bisect reset || echo -n
git checkout --detach HEAD || echo -n
git branch -D ${params.KERNEL_BRANCH} || echo -n
for t in \$(git tag -l | grep ${env.JOB_NAME}); do git tag -d \$t; done
git fetch ${params.KERNEL_TREE} ${params.KERNEL_BRANCH} --tags -f
git checkout ${params.GIT_COMMIT} -b ${params.KERNEL_BRANCH}
git symbolic-ref HEAD refs/heads/${params.KERNEL_BRANCH}
""")
    }
}

def fetchLabInfo(kci_core) {
    dir(kci_core) {
        def token = "${params.LAB}-lava-api"
        def retry = 3

        while (retry--) {
            try {
                withCredentials([string(credentialsId: token,
                                        variable: 'SECRET')]) {
            sh(script: """\
./kci_test \
get_lab_info \
--lab-config=${params.LAB} \
--lab-json=${env._LAB_JSON} \
--user=kernel-ci \
--lab-token=${SECRET} \
""")
                    retry = 0
                }
            } catch (error) {
                if (retry)
                    print("Error with ${lab}: ${error}, retrying...")
                else
                    throw error
            }
        }
        stash(name: env._LAB_JSON, includes: env._LAB_JSON)
    }
}

def buildKernel(kdir, kci_core) {
    def output = "${kdir}/build-${params.ARCH}-${params.BUILD_ENVIRONMENT}"
    dir(kci_core) {
        sh(script: "rm -f ${env._BMETA_JSON}")
        sh(script: "rm -f ${env._DTBS_JSON}")

        sh(script: """\
for d in \$(find ${kdir} -name "build-*" -type d); do
  [ "\$d" = "${output}" ] || rm -rf "\$d"
done
""")

        sh(script:"""\
./kci_build \
generate_defconfig_fragments \
--defconfig=${params.DEFCONFIG} \
--kdir=${kdir} \
""")

        def expanded_defconfig = sh(script: """\
./kci_build \
expand_fragments \
--defconfig=${params.DEFCONFIG} \
""", returnStdout: true).trim()

        sh(script:"""\
./kci_build \
build_kernel \
--kdir=${kdir} \
--defconfig=${expanded_defconfig} \
--arch=${params.ARCH} \
--build-env=${params.BUILD_ENVIRONMENT} \
--output=${output} \
--verbose \
""")

        sh(script: """\
./kci_build \
install_kernel \
--kdir=${kdir} \
--tree-name=${params.KERNEL_TREE} \
--tree-url=${params.KERNEL_URL} \
--branch=${params.KERNEL_BRANCH} \
--output=${output} \
&& echo OK || echo ERROR
""")

        withCredentials([string(credentialsId: params.KCI_API_TOKEN_ID,
                                variable: 'SECRET')]) {
            sh(script: """\
./kci_build \
push_kernel \
--kdir=${kdir} \
--db-token=${SECRET} \
--api=${params.KCI_API_URL} \
""")
        }

        dir("${kdir}/_install_") {
            stash(name: env._BMETA_JSON, includes: env._BMETA_JSON)
            stash(name: env._DTBS_JSON, includes: env.DTBS_JSON)
        }
    }
}

def submitJob(kci_core, describe, hook) {
    dir(kci_core) {
        sh(script: """\
rm -f ${env._BMETA_JSON} \
rm -f ${env._DTBS_JSON} \
rm -f ${env._LAB_JSON} \
""")
        unstash(env._BMETA_JSON)
        unstash(env._DTBS_JSON)
        unstash(env._LAB_JSON)

        def egg_cache = eggCache()
        def token = "${params.LAB}-lava-api"

        /* ToDo: deal with params.LAVA_PRIORITY or drop it */

        withCredentials([string(credentialsId: token, variable: 'SECRET')]) {
            sh(script: """ \
./kci_test \
generate \
--bmeta-json=${env._BMETA_JSON} \
--dtbs-json=${env._DTBS_JSON} \
--lab-json=${env._LAB_JSON} \
--storage=${params.KCI_STORAGE_URL} \
--lab-config=${params.LAB} \
--user=kernel-ci \
--lab-token=${SECRET} \
--callback-id=${params.LAVA_CALLBACK} \
--callback-url=${hook.getURL()} \
--callback-dataset=results \
--callback-type=custom \
--target=${params.TARGET} \
--plan=${params.TEST_PLAN_VARIANT} \
> job.yaml
""")

            sh(script: """ \
./kci_test \
submit \
--lab-config=${params.LAB} \
--user=kernel-ci \
--lab-token=${SECRET} \
--jobs=job.yaml \
""")
        }
    }
}

def getResult(kci_core, hook) {
    def status = null

    dir(kci_core) {
        echo "Waiting for job results..."
        def data = waitForWebhook(hook)
        def json_file = 'callback.json'
        writeFile(file: json_file, text: data)
        def token = "${params.LAB}-bisection-webhook"
        withCredentials([string(credentialsId: token, variable: 'SECRET')]) {
            def egg_cache = eggCache()
            status = sh(returnStatus: true, script: """
PYTHON_EGG_CACHE=${egg_cache} \
./scripts/lava-v2-callback.py \
--token=${SECRET} \
--test-case=${params.TEST_CASE} \
${json_file}
""")
        }
        sh(script: "rm -f ${json_file}")
    }

    return status
}

def runTest(kci_core, describe, expected=0, runs=null) {
    if (!runs)
        runs = params.TEST_RUNS.toInteger()

    def status = null

    for (int i = 1; i <= runs; i++) {
        echo "Run ${i} / ${runs}"

        def retries = 3

        while (retries) {
            def hook = registerWebhook()
            submitJob(kci_core, describe, hook)
            status = getResult(kci_core, hook)

            if (status == 1)
                retries -= 1
            else
                break
        }

        if (status != expected)
            break
    }

    return status
}

node("docker && bisection") {
    /* Global pipeline constants */
    env._BMETA_JSON = "bmeta.json"
    env._DTBS_JSON = "dtbs.json"
    env._LAB_JSON = "lab-info.json"

    def j = new Job()
    def kci_core = "${env.WORKSPACE}/kernelci-core"
    def kdir = "${env.WORKSPACE}/linux"
    def docker_image = null
    def tag = null

    print("""\
    Tree:      ${params.KERNEL_TREE}
    URL:       ${params.KERNEL_URL}
    Branch:    ${params.KERNEL_BRANCH}
    Commig:    ${params.GIT_COMMIT}
    Target:    ${params.TARGET}
    Lab:       ${params.LAB}
    Defconfig: ${params.DEFCONFIG}
    Compiler:  ${params.BUILD_ENVIRONMENT}
    Test plan: ${params.TEST_PLAN_VARIANT}""")

    j.dockerPullWithRetry("${params.DOCKER_BASE}build-base").inside() {
        stage("Docker") {
            j.cloneKciCore(
                kci_core, params.KCI_CORE_URL, params.KCI_CORE_BRANCH)
            build_env_docker_image = j.dockerImageName(
                kci_core, params.BUILD_ENVIRONMENT, params.ARCH)
            docker_image =
                "${params.DOCKER_BASE}build-${build_env_docker_image}"
        }
    }

    j.dockerPullWithRetry(docker_image).inside() {
        stage("Checkout") {
            timeout(time: 30, unit: 'MINUTES') {
                parallel(
                    kci_core: { cloneKciCore(kci_core) },
                    kdir: { cloneLinux(kdir) },
                )
                checkoutRevision(kdir, params.GIT_COMMIT)
                tag = createTag(kdir)
            }
        }

        stage("Lab info") {
            timeout(time: 1, unit: 'MINUTES') {
                fetchLabInfo(kci_core)
            }
        }

        stage("Build") {
            lock("${env.NODE_NAME}-build-lock") {
                timeout(time: 60, unit: 'MINUTES') {
                    buildKernel(kdir, kci_core)
                }
            }
        }

        stage("Test") {
            def describe = gitDescribe(kdir)
            timeout(time: 120, unit: 'MINUTES') {
                def status = runTest(kci_core, describe)
                print("Status: ${status}")
            }
        }

        stage("Cleanup") {
            removeTag(kdir, tag)
        }
    }
}
